# 🗓️ 2025.07.28(월) – 교육 일지

## 📚 오늘 배운 내용
### LLM
#### LLM과 파이썬
- 파이썬의 동작 과정
  - Python 코드가 곧바로 기계어로 실행되는 게 아니라 바이트코드로 변환된 후, 인터프리터(Python Virtual Machine)가 해석하면서 실행
  - 때문에 곧바로 기계어로 실행되는 C나 C++보다 느리다.
- 그렇다면 왜 파이썬이 LLM 개발할 때 사용될까?
  1. 생산성이 매우 높음 
     - Python은 문법이 간단해서 개발 속도가 매우 빠름. 
     - 머신러닝/딥러닝 연구는 실험이 많기 때문에, 빠르게 코드를 바꾸고 테스트해볼 수 있는 환경이 중요함.
  2. 막강한 라이브러리 생태계 
     - PyTorch, TensorFlow, NumPy, pandas, scikit-learn, HuggingFace 등 LLM에 필요한 도구들이 전부 Python 기반임. 
     - 수학, 통계, 행렬 연산, 데이터 전처리 등 LLM에 필요한 기능을 거의 다 지원함.
  3. 핵심 연산은 C/C++로 작성됨 
     - 실제로 모델 학습 시 속도가 중요한 부분은 Python이 아니라 내부적으로 C/CUDA로 동작함. 
       - 예: PyTorch의 torch.Tensor 연산은 대부분 C++이나 CUDA(그래픽카드용 언어)로 구현되어 있음. 
     - Python은 그 위에 얇은 인터페이스만 얹은 셸일 뿐임.
  
#### 파이썬 기초 문법
- 변수와 기본 타입
  - 데이터 타입을 선언해주지 않아도 동적으로 데이터 타입을 매핑해준다.
    ```
    team_name = '오지라퍼스' # 단어와 단어 사이를 _로 잇는 snake case를 사용하는 것이 표준
    price = 123456        # int
    is_active = True      # bool(논리형)
    user_data = None      # 값이 없음을 나타내는 NoneType(Java의 null)  
    ```
- f-string
  - 문자열 안에 변수나 표현식을 간편하게 넣을 수 있는 방법
    ```
    print(f"팀 이름 : {team_name}")
    ```
- List
  - Java의 ArrayList와 유사
  - 순서가 있는 가변 배열
  - 요소 중복 허용
  - 인덱스로 접근 가능
  - `append()`, `insert()`, `remove()`, `sort()` 등의 메소드를 제공한다.
    ```
    scores = [88, 95, 45]
    
    scores.append(100)   # 맨 뒤에 추가
    scores.insert(1, 70) # 1번 인덱스 위치에 70 삽입
    scores.remove(88) # 88 점수 제거
    scores.pop() # 인덱스를 주지 않으면 맨 뒤 요소를 꺼내고 제거
    ```
- Dictionary
  - Java의 HashMap과 유사
  - Key-Value 쌍의 가변 맵
    ```
    user = {'name' : '홍길동', 'age' : 30}
    
    user['job'] = '의적' # 'job' 키가 없으므로 새로 추가
    user ['age'] = 32   # 'age'키가 있으므로 값 수정
    
    # 안전하게 값 조회하기 
    # .get(키, 기본값) -> 키가 없을 때 에러 대신 지정한 기본값을 안전하게 반환
    email = user.get('email', '정보 없음')
    ```
- tuple
  - Java의 List.of(...)나 불변 배열과 유사
  - 순서가 있는 불변(immutable) 배열
  - 요소 중복 허용
  - 읽기 전용이므로 성능이 더 좋고 안전함
  - 괄호()로 선언
    ```
    point = (3, 4)
    print(point[0])  # 3
    
    # unpacking
    x, y = point
    print(x, y)  # 3 4
    ```
  - 불변이라서 값 추가/삭제/수정 불가능
  - 단, 튜플 내부에 리스트가 있으면 그 리스트는 수정 가능
    ```
    t = (1, 2, [3, 4])
    t[2].append(5)  # 가능
    print(t)  # (1, 2, [3, 4, 5])
    ```
- 얕은 복사, 깊은 복사
  - 얕은 복사
    - 객체의 참조(주소)만 복사함
    - 복사한 객체와 원본 객체는 같은 내부 객체(mutable한 경우)를 공유
  - 깊은 복사
    - 객체와 그 내부의 모든 객체까지 재귀적으로 새로운 복사본을 만듦.
    - 복사한 객체와 원본 객체는 완전히 독립적
      ```
      new_price = prices.copy() #.copy()를 사용한다.
      ```
- 문자열 슬라이싱
  ```
  문자열[시작 인덱스:끝 인덱스:간격]
  ```
  - 시작 인덱스: 자르기 시작할 위치 (포함)
  - 끝 인덱스: 자르기 종료할 위치 (❗포함 X)
  - 간격 (step): 몇 칸씩 건너뛸지 (생략 가능, 기본값은 1)
  - 예시
    ```
    txt = "hello world"
    ```
    | 슬라이싱 코드     | 설명           | 결과              |
    | ----------- | ------------ | --------------- |
    | `txt[:5]`   | 처음부터 5번째 전까지 | `"hello"`       |
    | `txt[6:]`   | 6번째부터 끝까지    | `"world"`       |
    | `txt[::2]`  | 2칸씩 건너뛰며 자르기 | `"hlowrd"`      |
    | `txt[::-1]` | 문자열 뒤집기 (역순) | `"dlrow olleh"` |
- 문자열 함수
  - split()
    - 문자열을 특정 구분자 기준으로 나누어 리스트로 반환 (문자열 -> 리스트)
      ````
      txt = "사과,바나나,딸기"
      result = txt.split(",")
      print(result)  # ['사과', '바나나', '딸기']
      ````
    - 기본 구분자는 공백 (" "): txt.split()
    - 파싱, CSV 처리할 때 많이 씀
    - 문자열이 없으면 전체 문자열이 리스트 하나로 들어감
  - join()
    - 리스트 요소들을 하나의 문자열로 결합 (리스트 -> 문자열)
      ```
      fruits = ['사과', '바나나', '딸기']
      result = ",".join(fruits)
      print(result)  # 사과,바나나,딸기
      ```
    - 리스트 요소는 모두 문자열이어야 함
    - "구분자".join(리스트) 형식
    - 자바스크립트의 join과 파이썬의 join
    
      | 언어     | 주체  | 메서드 위치         | 예시                 |
      | ------ | --- | -------------- | ------------------ |
      | 자바스크립트 | 리스트 | 리스트(Array)에 정의 | `fruits.join(',')` |
      | 파이썬    | 문자열 | 문자열(str)에 정의   | `','.join(fruits)` |
  - replace()
    - 문자열 내에서 특정 문자열을 다른 문자열로 바꿔 반환
      ```
      txt = "나는 바나나를 좋아해"
      result = txt.replace("바나나", "사과")
      print(result)  # 나는 사과를 좋아해
      ```
    - 기존 문자열은 변경되지 않고, 변경된 새 문자열을 반환함
    - 치환 대상 문자열이 여러 개일 경우 모두 바뀜
      ````
      txt = "바나나 바나나 바나나"
      result = txt.replace("바나나", "사과")
      print(result)  # 사과 사과 사과
      ````
    - 치환 횟수를 지정할 수도 있음 (앞에서부터 순서대로 지정한 횟수만큼 치환)
      ````
      txt = "바나나 바나나 바나나"
      result = txt.replace("바나나", "사과", 2)
      print(result)  # 사과 사과 바나나
      ````
    - 대소문자 구분함
- 반복문으로 리스트 & 딕셔너리 조회
  - 리스트 반복
    ```
    foods = ['햄버거', '치킨', '피자']
    for food in foods:
    print(f"오늘의 메뉴 : {food}")
    ```
  - 딕셔너리 반복
    ```
    user_info = {'name': '이순신', 'age': 45}

    # key, value 모두 조회
    for key, value in user_info.items():
    print(f"- {key} : {value}")
    
    # key만 조회
    for key in user_info.keys():
    print(key)
    
    # value만 조회
    for value in user_info.values():
    print(value)
    ```
    - .items() → (key, value) 쌍 반환
    - .keys() → key만 반환
    - .values() → value만 반환
  - 딕셔너리 문자열 포맷팅
    ```
    prompt = f"사용자 '{user_info['name']}' (나이 : {user_info['age']})에 대한 요약 보고서를 작성해주세요."
    print("생성된 프롬프트 ", prompt)
    ```

## ✍️ 오늘의 회고
- 드디어 LLM 시작이다. 나도 얼른 AI 챗봇 만들어서 프로젝트에 적용시키고 싶다!